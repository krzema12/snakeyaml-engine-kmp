package it.krzeminski.copydsl.impl

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.UNIT
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo

class CopyDslSymbolProcessor(
    private val codeGenerator: CodeGenerator,
    private val copyAnnotationFqn: String,
) : SymbolProcessor {
    private var wasRun = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (!wasRun) {
            addCopyDslForAnnotatedClasses(resolver = resolver)
            wasRun = true
        }
        return emptyList()
    }

    private fun addCopyDslForAnnotatedClasses(resolver: Resolver) =
        resolver.getSymbolsWithAnnotation(copyAnnotationFqn)
            .forEach { symbol ->
                if (symbol is KSClassDeclaration) {
                    generateCopyDslFile(symbol = symbol)
                }
            }

    private fun generateCopyDslFile(symbol: KSClassDeclaration) =
        buildFileSpec(symbol = symbol)
            .writeTo(codeGenerator = codeGenerator, aggregating = false)

    private fun buildFileSpec(symbol: KSClassDeclaration): FileSpec {
        val interfaceName = "Mutable${symbol.simpleName.asString()}"
        return FileSpec
            .builder(packageName = symbol.packageName.asString(), fileName = symbol.simpleName.asString() + "CopyDsl")
            .addFileComment("This file was generated by copy-dsl-ksp-processor. Do not edit manually.")
            .addType(buildInterfaceSpec(symbol = symbol, interfaceName = interfaceName))
            .addFunction(buildCopyFunctionSpec(symbol = symbol, interfaceName = interfaceName))
            .build()
    }

    private fun buildInterfaceSpec(symbol: KSClassDeclaration, interfaceName: String): TypeSpec =
        TypeSpec.interfaceBuilder(interfaceName)
            .addProperties(symbol.primaryConstructor!!.parameters
                .map { parameter -> PropertySpec.builder(parameter.name!!.asString(), parameter.type.toTypeName())
                    .mutable(true)
                    .build() })
            .build()

    private fun buildCopyFunctionSpec(symbol: KSClassDeclaration, interfaceName: String): FunSpec =
        FunSpec.builder("copy")
            .receiver(symbol.asType(emptyList()).toTypeName())
            .addParameter(
                ParameterSpec.builder(
                    "modifications",
                    buildModificationsType(symbol = symbol, interfaceName = interfaceName)
                ).build()
            )
            .returns(symbol.asType(emptyList()).toTypeName())
            .addStatement(
                "val result = %L.apply(modifications)",
                buildMutableInstance(symbol, interfaceName)
            )
            .addStatement(
                "return %T(%L)",
                symbol.asType(emptyList()).toTypeName(),
                symbol.primaryConstructor!!.parameters.joinToString(", ") { "${it.name!!.asString()} = result.${it.name!!.asString()}" })
            .build()

    private fun buildModificationsType(symbol: KSClassDeclaration, interfaceName: String): LambdaTypeName =
        LambdaTypeName.get(
            receiver = ClassName(symbol.packageName.asString(), interfaceName),
            parameters = emptyList(),
            returnType = UNIT,
        )

    private fun buildMutableInstance(symbol: KSClassDeclaration, interfaceName: String): TypeSpec =
        TypeSpec.anonymousClassBuilder()
            .addSuperinterface(ClassName(symbol.packageName.asString(), interfaceName))
            .addProperties(
                symbol.primaryConstructor!!.parameters
                    .map { parameter ->
                        PropertySpec.builder(parameter.name!!.asString(), parameter.type.toTypeName())
                            .addModifiers(KModifier.OVERRIDE)
                            .mutable(true)
                            .initializer("%L", CodeBlock.of("this@copy.${parameter.name!!.asString()}"))
                            .build()
                    }
            )
            .build()
}
