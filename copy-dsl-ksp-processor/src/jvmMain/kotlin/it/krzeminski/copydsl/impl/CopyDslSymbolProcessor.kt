package it.krzeminski.copydsl.impl

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.LambdaTypeName
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.UNIT
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo

class CopyDslSymbolProcessor(
    private val codeGenerator: CodeGenerator,
) : SymbolProcessor {
    private var wasRun = false

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (wasRun) {
            return emptyList()
        }
        wasRun = true
        resolver.getSymbolsWithAnnotation("it.krzeminski.copydsl.api.CopyDsl").forEach { symbol ->
            if (symbol is KSClassDeclaration) {
                val interfaceName = "Mutable${symbol.simpleName.asString()}"
                val interfaceSpec = TypeSpec.interfaceBuilder(interfaceName)
                    .addProperties(symbol.primaryConstructor!!.parameters
                        .map { parameter -> PropertySpec.builder(parameter.name!!.asString(), parameter.type.toTypeName())
                            .mutable(true)
                            .build() })
                    .build()
                val modificationsType = LambdaTypeName.get(
                    receiver = ClassName(symbol.packageName.asString(), interfaceName),
                    parameters = emptyList(),
                    returnType = UNIT,
                )
                val anonymousObject = TypeSpec.anonymousClassBuilder()
                    .addSuperinterface(ClassName(symbol.packageName.asString(), interfaceName))
                    .addProperties(
                        symbol.primaryConstructor!!.parameters
                            .map { parameter ->
                                PropertySpec.builder(parameter.name!!.asString(), parameter.type.toTypeName())
                                    .addModifiers(KModifier.OVERRIDE)
                                    .mutable(true)
                                    .initializer("%L", CodeBlock.of("this@copy.${parameter.name!!.asString()}"))
                                    .build()
                            }
                    )
                    .build()
                val fileSpec = FileSpec
                    .builder(packageName = symbol.packageName.asString(), fileName = symbol.simpleName.asString() + "CopyDsl")
                    .addFileComment("This file was generated by copy-dsl-ksp-processor. Do not edit manually.")
                    .addType(interfaceSpec)
                    .addFunction(
                        FunSpec.builder("copy")
                            .receiver(symbol.asType(emptyList()).toTypeName())
                            .addParameter(ParameterSpec.builder("modifications", modificationsType).build())
                            .returns(symbol.asType(emptyList()).toTypeName())
                            .addStatement("val result = %L.apply(modifications)", anonymousObject)
                            .addStatement("return %T(%L)", symbol.asType(emptyList()).toTypeName(), symbol.primaryConstructor!!.parameters.joinToString(", ") { "${it.name!!.asString()} = result.${it.name!!.asString()}" })
                            .build()
                    )
                    .build()
                fileSpec.writeTo(codeGenerator = codeGenerator, aggregating = false)
            }
        }
        return emptyList()
    }
}
